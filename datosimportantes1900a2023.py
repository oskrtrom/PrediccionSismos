# -*- coding: utf-8 -*-
"""DatosImportantes1900a2023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ifci2fOVrHhMlVKrALMv1fKvrK7LAsNk
"""

import pandas as pd

# Ruta al archivo CSV
ruta_archivo = 'Significant Earthquake Dataset 1900-2023.csv'

# Cargar el archivo CSV en un DataFrame de pandas
datos_sismicos = pd.read_csv(ruta_archivo)

# Verificar las primeras filas del DataFrame
print(datos_sismicos.head())

# Parseo de fechas y establecimiento como índice
datos_sismicos['Time'] = pd.to_datetime(datos_sismicos['Time'])
datos_sismicos.set_index('Time', inplace=True)

# Verificar las primeras filas del DataFrame después del procesamiento
print(datos_sismicos.head())

import pandas as pd

# Ruta al archivo CSV
ruta_archivo = 'Significant Earthquake Dataset 1900-2023.csv'

# Cargar el archivo CSV en un DataFrame de pandas
datos_sismicos = pd.read_csv(ruta_archivo)

# Parseo de fechas y establecimiento como índice
datos_sismicos['Time'] = pd.to_datetime(datos_sismicos['Time'])
datos_sismicos.set_index('Time', inplace=True)

# Exploración de datos
print(datos_sismicos.info())
print(datos_sismicos.describe())

import matplotlib.pyplot as plt

# Gráfico de series temporales
plt.plot(datos_sismicos.index, datos_sismicos['Mag'], marker='o')
plt.title('Serie Temporal de Magnitudes de Terremotos')
plt.xlabel('Fecha')
plt.ylabel('Mag')
plt.show()

import matplotlib.pyplot as plt

# Gráfico de series temporales
plt.figure(figsize=(20, 10))

# Añadir la serie temporal
plt.plot(datos_sismicos.index, datos_sismicos['Mag'], marker='o', linestyle='-', color='b', label='Magnitudes')

# Personalizar el gráfico
plt.title('Serie Temporal de Magnitudes de Terremotos', fontsize=16)
plt.xlabel('Fecha', fontsize=10)
plt.ylabel('Magnitud', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.7)

# Añadir leyenda
plt.legend(loc='upper left')

# Rotar las etiquetas del eje x para una mejor legibilidad
plt.xticks(rotation=45, ha='right')

# Añadir líneas de cuadrícula horizontales para guiar la lectura de las magnitudes
for mag in range(5, 11):
    plt.axhline(y=mag, color='gray', linestyle='--', linewidth=0.5, alpha=0.7)

# Resaltar los puntos donde la magnitud es mayor que 7
plt.scatter(datos_sismicos.index[datos_sismicos['Mag'] > 7], datos_sismicos['Mag'][datos_sismicos['Mag'] > 7],
            color='red', label='Magnitudes > 7')

# Añadir texto de anotación
for i, mag in enumerate(datos_sismicos['Mag']):
    if mag > 7:
        plt.annotate(f'{mag:.1f}', (datos_sismicos.index[i], mag + 0.1), ha='center', color='red')

# Ajustar el diseño para evitar solapamiento
plt.tight_layout()

# Mostrar el gráfico
plt.show()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd

# Gráfico de series temporales con mejoras
plt.figure(figsize=(12, 6))

# Añadir la serie temporal
plt.plot(datos_sismicos['Time'], datos_sismicos['Mag'], marker='o', linestyle='-', color='b', label='Magnitudes')

# Personalizar el gráfico
plt.title('Serie Temporal de Magnitudes de Terremotos', fontsize=16)
plt.xlabel('Fecha', fontsize=14)
plt.ylabel('Magnitud', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.7)

# Añadir leyenda
plt.legend(loc='upper left')

# Rotar las etiquetas del eje x para una mejor legibilidad
plt.xticks(rotation=45, ha='right')

# Añadir líneas de cuadrícula horizontales para guiar la lectura de las magnitudes
for mag in range(5, 11):
    plt.axhline(y=mag, color='gray', linestyle='--', linewidth=0.5, alpha=0.7)

# Resaltar los puntos donde la magnitud es mayor que 7
plt.scatter(datos_sismicos['Time'][datos_sismicos['Mag'] > 7], datos_sismicos['Mag'][datos_sismicos['Mag'] > 7],
            color='red', label='Magnitudes > 7')

# Añadir texto de anotación
for i, mag in enumerate(datos_sismicos['Mag']):
    if mag > 7:
        plt.annotate(f'{mag:.1f}', (datos_sismicos['Time'][i], mag + 0.1), ha='center', color='red')

# Establecer límites específicos en el eje x
fecha_inicio = pd.to_datetime('2023-01-01')
plt.xlim(left=fecha_inicio)

# Configurar el formato de las fechas en el eje x
plt.gca().xaxis.set_major_locator(mdates.YearLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))

# Ajustar el diseño para evitar solapamiento
plt.tight_layout()

# Mostrar el gráfico
plt.show()

# Manejo de datos atípicos
datos_sismicos_sin_atipicos = datos_sismicos[(datos_sismicos['Mag'] > 3.0) & (datos_sismicos['Mag'] < 9.0)]

# Selección de características relevantes
caracteristicas_seleccionadas = ['Mag', 'Depth', 'Latitude', 'Longitude']
datos_sismicos_seleccionados = datos_sismicos_sin_atipicos[caracteristicas_seleccionadas]

# Identificación de datos faltantes
datos_faltantes = datos_sismicos_seleccionados.isnull().sum()

# Imputación de datos usando la mediana
datos_sismicos_imputados = datos_sismicos_seleccionados.fillna(datos_sismicos_seleccionados.median())

# Evaluación del impacto
estadisticas_despues_imputacion = datos_sismicos_imputados.describe()

# Visualización comparativa antes y después de la imputación
plt.figure(figsize=(12, 6))

# Gráfico antes de la imputación
plt.subplot(1, 2, 1)
plt.title('Antes de la Imputación')
plt.hist(datos_sismicos_seleccionados['Mag'].dropna(), bins=20, color='blue', alpha=0.7, label='Original')
plt.legend()

# Gráfico después de la imputación
plt.subplot(1, 2, 2)
plt.title('Después de la Imputación')
plt.hist(datos_sismicos_imputados['Mag'], bins=20, color='green', alpha=0.7, label='Imputado')
plt.legend()

plt.show()

# Supongamos que tienes una columna 'Mag' que representa la magnitud de los sismos
umbral_magnitud = 5.0  # Puedes ajustar este umbral según tus necesidades

# Crear la columna 'Clase' basada en el umbral de magnitud
datos_sismicos['Clase'] = (datos_sismicos['Mag'] > umbral_magnitud).astype(int)

# Visualizar las primeras filas del DataFrame con la nueva columna 'Clase'
print(datos_sismicos.head())

import matplotlib.pyplot as plt

# Supongamos que ya tienes un DataFrame llamado 'datos_sismicos' con la columna 'Clase'

# Contar la frecuencia de cada clase
frecuencia_clases = datos_sismicos['Clase'].value_counts()

# Crear un gráfico de barras
plt.figure(figsize=(8, 5))
frecuencia_clases.plot(kind='bar', color=['blue', 'red'], alpha=0.7)

# Personalizar el gráfico
plt.title('Distribución de Clases')
plt.xlabel('Clase')
plt.ylabel('Frecuencia')
plt.xticks([0, 1], ['Menor o igual al umbral', 'Mayor al umbral'], rotation=0)

# Mostrar el gráfico
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
# División de datos en conjuntos de entrenamiento y prueba
X = datos_sismicos_imputados[['Depth', 'Latitude', 'Longitude']]
y = datos_sismicos_imputados['Mag']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Inicialización y entrenamiento del modelo de regresión lineal
modelo_regresion_lineal = LinearRegression()
modelo_regresion_lineal.fit(X_train, y_train)
# Predicciones en el conjunto de prueba
predicciones = modelo_regresion_lineal.predict(X_test)
# Evaluación del rendimiento
mse = mean_squared_error(y_test, predicciones)
print(f"Error cuadrático medio (MSE): {mse}")
# Visualización de las predicciones vs. observaciones reales
plt.scatter(y_test, predicciones)
plt.xlabel('Magnitud Real')
plt.ylabel('Magnitud Predicha')
plt.title('Predicciones vs. Observaciones Reales en Regresión Lineal')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
# Visualización de la ACF y PACF para determinar los parámetros de ARIMA
plt.figure(figsize=(12, 6))
plt.subplot(2, 1, 1)
plot_acf(datos_sismicos_imputados['Mag'], ax=plt.gca(), lags=40)
plt.subplot(2, 1, 2)
plot_pacf(datos_sismicos_imputados['Mag'], ax=plt.gca(), lags=40)
plt.show()
# Ajuste automático del modelo ARIMA
modelo_arima = ARIMA(datos_sismicos_imputados['Mag'], order=(2, 1, 1))
resultado_arima = modelo_arima.fit()
# Visualización de los resultados
print(resultado_arima.summary())
# Obtención de predicciones
predicciones = resultado_arima.get_forecast(steps=20)
intervalo_confianza = predicciones.conf_int()
# Visualizar la serie temporal y las predicciones
plt.figure(figsize=(12, 6))
plt.plot(datos_sismicos_imputados['Mag'], label='Observado')
plt.plot(predicciones.predicted_mean, color='red', label='Predicción')
plt.fill_between(intervalo_confianza.index,
                 intervalo_confianza.iloc[:, 0],
                 intervalo_confianza.iloc[:, 1], color='red', alpha=0.2, label='Intervalo de Confianza')
plt.title('Predicción de Magnitudes de Terremotos con ARIMA')
plt.xlabel('Fecha')
plt.ylabel('Mag')
plt.legend()
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from io import StringIO

ruta_archivo = 'Significant Earthquake Dataset 1900-2023.csv'
datos_sismicos = pd.read_csv(ruta_archivo)

# Convertir la columna de fechas a formato datetime si aún no está en ese formato
datos_sismicos['Time'] = pd.to_datetime(datos_sismicos['Time'])

# Ordenar los datos por fecha
datos_sismicos.sort_values(by='Time', inplace=True)

# Calcular las diferencias entre fechas consecutivas
diferencias_temporales = datos_sismicos['Time'].diff()

# Convertir las diferencias temporales a días (o la unidad que prefieras)
diferencias_temporales_dias = diferencias_temporales / np.timedelta64(1, 'D')

# Histograma de las diferencias temporales convertidas
plt.figure(figsize=(12, 6))
plt.hist(diferencias_temporales_dias.dropna(), bins=50, color='blue', alpha=0.7)
plt.title('Histograma de Diferencias Temporales entre Sismos')
plt.xlabel('Diferencia Temporal (días)')
plt.ylabel('Frecuencia')
plt.show()

# Análisis de autocorrelación
autocorrelacion = diferencias_temporales_dias.autocorr()
print(f"Autocorrelación de las diferencias temporales: {autocorrelacion}")

# Visualización de fechas para detectar patrones visuales
plt.figure(figsize=(12, 6))
plt.plot(datos_sismicos['Time'], np.zeros_like(datos_sismicos['Time']), 'o', label='Sismos')
plt.title('Visualización de Fechas de Sismos')
plt.xlabel('Fecha')
plt.gca().xaxis.set_major_locator(mdates.YearLocator())  # Establecer el localizador de años
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))  # Formato de fecha
plt.xticks(rotation=45)  # Rotar las etiquetas para mejor legibilidad
plt.legend()
plt.tight_layout()  # Ajustar el diseño para evitar solapamiento
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from io import StringIO

# Leer el archivo CSV que ya está en Colab
ruta_archivo = 'Significant Earthquake Dataset 1900-2023.csv'  # Reemplaza con la ruta correcta
datos_sismicos = pd.read_csv(ruta_archivo)

# Convertir la columna de fechas a formato datetime si aún no está en ese formato
datos_sismicos['Time'] = pd.to_datetime(datos_sismicos['Time'])

# Ordenar los datos por fecha
datos_sismicos.sort_values(by='Time', inplace=True)

# Calcular las diferencias entre fechas consecutivas
diferencias_temporales = datos_sismicos['Time'].diff()

# Convertir las diferencias temporales a días (o la unidad que prefieras)
diferencias_temporales_dias = diferencias_temporales / np.timedelta64(1, 'D')

# Histograma de las diferencias temporales convertidas
plt.figure(figsize=(12, 6))
plt.hist(diferencias_temporales_dias.dropna(), bins=50, color='blue', alpha=0.7)
plt.title('Histograma de Diferencias Temporales entre Sismos')
plt.xlabel('Diferencia Temporal (días)')
plt.ylabel('Frecuencia')
plt.show()

# Análisis de autocorrelación
autocorrelacion = diferencias_temporales_dias.autocorr()
print(f"Autocorrelación de las diferencias temporales: {autocorrelacion}")

# Visualización de fechas para detectar patrones visuales
plt.figure(figsize=(40, 6))
plt.plot(datos_sismicos['Time'], np.zeros_like(datos_sismicos['Time']), 'o', label='Sismos')
plt.title('Visualización de Fechas de Sismos')
plt.xlabel('Fecha')
plt.gca().xaxis.set_major_locator(mdates.YearLocator())  # Establecer el localizador de años
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))  # Formato de fecha
plt.xticks(rotation=45)  # Rotar las etiquetas para mejor legibilidad
plt.legend()
plt.tight_layout()  # Ajustar el diseño para evitar solapamiento
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Supongamos que 'datos_sismicos_imputados' es tu DataFrame con los datos imputados

# Calcular la matriz de correlación
correlation_matrix = datos_sismicos_imputados.corr()

# Visualizar la matriz de correlación con seaborn
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Matriz de Correlación')
plt.show()

import pandas as pd
from statsmodels.tsa.arima.model import ARIMA

# Supongamos que 'datos_sismicos_imputados' es tu DataFrame con los datos imputados

# Seleccionar la serie temporal de magnitudes de terremotos
serie_temporal = datos_sismicos_imputados['Mag']

# Entrenar el modelo ARIMA
modelo_arima = ARIMA(serie_temporal, order=(2, 1, 1))  # Ajustar los órdenes según sea necesario
resultado_arima = modelo_arima.fit()

# Obtener las predicciones para el año 2024
predicciones_2024 = resultado_arima.get_forecast(steps=12)  # Suponiendo 12 meses en el año

# Obtener el intervalo de confianza para las predicciones
intervalo_confianza = predicciones_2024.conf_int()

# Visualizar las predicciones y el intervalo de confianza
plt.figure(figsize=(12, 6))
plt.plot(serie_temporal.index, serie_temporal, label='Observado')
plt.plot(predicciones_2024.predicted_mean.index, predicciones_2024.predicted_mean, color='red', label='Predicción')
plt.fill_between(intervalo_confianza.index,
                 intervalo_confianza.iloc[:, 0],
                 intervalo_confianza.iloc[:, 1], color='red', alpha=0.2, label='Intervalo de Confianza')
plt.title('Predicción de Magnitudes de Terremotos para 2024 con ARIMA')
plt.xlabel('Fecha')
plt.ylabel('Mag')
plt.legend()
plt.show()

# Supongamos que tienes una columna 'Mag' que representa la magnitud de los sismos
umbral_magnitud = 5.0  # Puedes ajustar este umbral según tus necesidades

# Crear la columna 'Clase' basada en el umbral de magnitud
datos_sismicos['Clase'] = (datos_sismicos['Mag'] > umbral_magnitud).astype(int)

# Visualizar las primeras filas del DataFrame con la nueva columna 'Clase'
print(datos_sismicos.head())